---
title: "Programmeren: exploratief en constructief"
author: EJD
layout: draft
date: 8-Nov-2014
---

Aan de ene kant horen we "programmeren is gemakkelijk: een kind kan het", aan de andere kant: "programmeren is moeilijk: Informatica-studenten en professionals hebben er grote moeite mee". Hebben we het wel over hetzelfde?

Zelf heb ik programmeren op twee manieren geleerd, als student Elektrotechniek aan de Technische Hogeschool Twente. (Informatica bestond nog niet als opleiding.) Voor het vak "Programmeren" moesten we opdrachten maken in Algol60. Het programma schreven we met potlood op speciaal blokjespapier. Dit leverden we in: dan werd het programma voor ons(!) overgetikt op ponskaarten. Deze werden verwerkt op de mainframe-computer van de universiteit, een IBM-360. Een dag later kregen we de printer-uitvoer van het programma en de verwerking daarvan. Als je niet heel zorgvuldig was, bestond deze uitvoer uit een foutmelding, of een foutief resultaat.

Programmeren deed je met potlood en papier. En natuurlijk met vlakgom: als je een programma schrijft, blijf je verbeteren en herschrijven. (Het toppunt van optimisme: een programmeur die met pen schrijft.)

Daarnaast maakte ik in mijn vrije tijd gebruik van de interactieve mogelijkheden van de IBM-360. In een paar kamers stonden *terminals*: elektrische schrijfmachines voor interactieve invoer en uitvoer op papier. Deze kon je per half uur reserveren: 's ochtends APL, 's middags Basic. Beide werken met een interpreter, met interactie via een REPL: read-eval-print-loop. Hierop probeerde ik mijn eigen programma's uit. Voor mij was de ervaring van een computer die mijn opdrachten gehoorzaam uitvoerde  fascinerend: formules die tot leven komen.

Achteraf denk ik dat beide belangrijk zijn: door het interactieve gebruik bouw je intuitie op, en een vaardigheid in exploreren en experimenteren. Het is fascinerend, en soms verslavend. Door het werken met potlood en papier, met een langzame feedback, leer je nadenken over problemen, programma's en processen. Dit is hard nodig omdat computers autonoom werken, in een andere ruimte-tijd werken dan mensen. Je moet alles van te voren proberen te overzien.

De eerste vorm zou ik *exploratief programmeren* willen noemen, de tweede *constructief programmeren*. Bij exploratief programmeren werk je "bottom-up", vanuit de beschikbare middelen. Vaak heb je geen vast omlijnd resultaat voor ogen; of, als je dat hebt, pas je het aan als het met de middelen niet snel genoeg lukt. Het resultaat is vaak niet eens belangrijk: je gooit het weg, of gebruikt het alleen zelf. Het gaat vaak om het effect, meer dan om de kwaliteit. Bij constructief programmeren gaat het om het oplossen van een bepaald probleem, waar je dan de middelen bij moet zoeken. Het is doelgericht. De oplossing moet door anderen gebruikt kunnen worden: kwaliteit, betrouwbaarheid en efficiëntie is essentieel.

We kunnen de verschillen samenvatten:

| Exploratief programmeren                    | Constructief programmeren |
| :---                                        | :---                      |
| voornamelijk voor (en met) jezelf           | voor (en met) anderen                      |
| korte cycli, direct contact met computer    | langere cycli, afstand tot computer        |
| vanuit technologie iets interessants maken  | relevant probleem oplossen met technologie |
| probleem aanpassen aan mogelijkheden        | oplossing zoeken bij gegeven probleem      |
| open einde                                  | duidelijke doelstellingen; resources       |
| gericht op effect                           | kwaliteit van oplossing essentieel:        |
| kwaliteit niet belangrijk                   | betrouwbaarheid, efficiëntie, evolutie, ...|
| gebruik van Copy/Paste, Remix               | gebruik van officiële interfaces (APIs)    |
| begrijpen van technologie, intuïtie         | redeneren over programma's en problemen    |
| eigen interesse                             | professionele normen                       |
| systematisch experimenteren                 | systematisch nadenken en redeneren         |

Een belangrijke constatering lijkt mij dat je je in beide aspecten kunt ontwikkelen. In beide kun je onderwijs geven. In beide kun je op een systematische manier te werk gaan, waardoor je veel verder komt dan met puur trial-and-error en ervaring.

Nog een opmerking over creativiteit: deze speelt in mijn ogen bij beide een rol.

Een opmerking tussendoor over programmeertalen: vanaf het eerste begin heb ik met meerdere programmeertalen gewerkt. Dat heeft mij, denk ik, geholpen om de programmeerconcepten vanaf het begin los te zien van de notatie en spelregels van een programmeertaal. De kans op verwarring was niet zo groot, omdat het in twee gescheiden werelden gebeurde.

En hoe zit het nu met de tegenstelling: programmeren - gemakkelijk en leuk - of moeilijk en frustrerend? 

Exploratief programmeren is laagdrempelig. Hiermee kun je al vrij snel aardige resultaten bereiken. Maar om echt verder te komen, heb je ook kennis van constructief programmeren nodig. Zonder constructief programmeren krijg je geen programma's die zo betrouwbaar zijn dat anderen deze kunnen gebruiken. In beide aspecten kun je je verder ontwikkelen, en beide hebben zin, ook voor professionals. 

> De Agile aanpak verenigt beide: waar in een puur waterval-model vooral de analyse vooraf een rol speelt, gebruikt de Agile aanpak een slimme combinatie van constructief en exploratief programmeren. Voor veel programmeurs heeft dit het plezier in het werk en de productiviteit aanzienlijk vergroot.

Als ik programmeer - wat ik nog steeds met veel plezier doe - combineer ik vaak beide aspecten. Een nieuwe programmeertaal of -omgeving verken ik op een explorerende manier. Als het resultaat voor anderen bruikbaar moet zijn, of als het een lastiger probleem betreft, gebruik ik de constructieve aanpak. Als het echt lastig wordt, komt daar nog steeds pen en papier aan te pas.
